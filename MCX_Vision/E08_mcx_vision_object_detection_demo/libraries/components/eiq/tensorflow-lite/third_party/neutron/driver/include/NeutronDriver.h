/*
 * Copyright 2022-2023 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#ifndef NEUTRON_DRIVER_H
#define NEUTRON_DRIVER_H

#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>
#include <stdint.h>

#include "NeutronErrors.h"

/* Neutron Driver error category codes */
typedef enum ERROR_CATEGORY_DRIVER {
    ERROR_CATEGORY_DRIVER_GENERIC,        /* Generic error category */
    ERROR_CATEGORY_DRIVER_UNSUPPORTED,    /* Unsupported function */
    ERROR_CATEGORY_DRIVER_UCODE,          /* Microcode bad magic or version incompatible. */
    ERROR_CATEGORY_DRIVER_INVALID,        /* Invalid arguments */
    ERROR_CATEGORY_DRIVER_BAD_HANDLE,     /* Bad inference handle */
    ERROR_CATEGORY_DRIVER_NO_MEMORY,      /* Not enough memory */
    ERROR_CATEGORY_DRIVER_INTERNAL_FAULT, /* Internal error */
    ERROR_CATEGORY_DRIVER_UNKNOWN_ARCH,   /* Unknown architecture */
    ERROR_CATEGORY_DRIVER_TRACE_NOT_RUN   /* Tracing did not run, but trace buffer was requested. */
} ERROR_CATEGORY_DRIVER;

/// Trace configuration to enable kernel level tracing.
#define TRACE_CONFIG_KERNEL_LEVEL (1U << 0)

/// Trace confinguration to enable job level tracing.
#define TRACE_CONFIG_JOB_LEVEL (1U << 1)

/* Neutron Driver errors */
#define GEN_NEUTRON_DRIVER_ERROR(category, code) GEN_NEUTRON_ERROR(ERROR_COMPONENT_DRIVER, category, code)
#define GEN_NEUTRON_DRIVER_GENERIC_ERROR()       GEN_NEUTRON_DRIVER_ERROR(ERROR_CATEGORY_DRIVER_GENERIC, __LINE__)

/// Questions:
/// 1. What are the states and the state diagram of the driver and firmware?
/// 2. How is the debug/profiling buffer handled (separate or same buffer)?
/// 3. Is the firmware image initialization the responsibility of the driver? If yes then why and how?

/// Type definition for a Neutron signal handle.
typedef void *NeutronSignal;

/// Type definition for a Neutron model handle. This is an identifier used to uniquely identify a model.
/// The convention is that the value NEUTRON_INVALID_HANDLE handle corresponds to an invalid handle.
typedef void *NeutronModelHandle;

/// TODO: Provide the scratch buffer as pointer in the structure (we should allow to be allocated by application):
///       - If the buffer is NULLPTR than the driver can allocate that buffer.
///       - Thus we have the flexibility of allowing the scratch to be allocated by either the driver or the
///       application.
typedef struct {
    /// Neutron microcode buffer address.
    /// The Neutron microcode is generated by the Neutron converter tool.
    /// The microcode buffer is allocated and initialized by the application or ML framework.
    /// The microcode buffer is passed by reference to the Neutron firmware.
    /// The microcode buffer is specific for a given ML model.
    const void *microcode;

    /// Neutron weights buffer address.
    /// The Neutron weights is generated by the Neutron converter tool.
    /// The weights buffer is allocated and initialized by the application or ML framework.
    /// The weights buffer address is passed by reference to the Neutron-firmware.
    /// The weights buffer is specific for a given ML model.
    const void *weights;

} NeutronModelConfig;

typedef struct {
    /// The input buffers of the model.
    /// The input buffers are allocated and initialized by the application or ML framework.
    /// The input buffers are passed by reference to the Neutron firmware.
    const void **inputs;

    /// The output buffers of the model.
    /// The output buffers are allocated by the application or ML framework.
    /// The output buffers are passed by reference to the Neutron firmware.
    void **outputs;

    /// Scratch buffer required for intermediate model computations.
    /// If NULL, this buffer has to be allocated by the driver.
    void *scratch;
} NeutronDataConfig;

typedef struct {
    /// Sets whether tracing should be executed during firmware run or not.
    /// If set to 0, tracing will not run.
    /// If set to 1 - kernel level tracing.
    /// If set to 2 - job level tracing.
    /// If set to 3 - mixed level tracing
    uint32_t traceConfig;

    /// Buffer to store collected trace data.
    /// If it is NULLPTR, driver will allocate the memory, otherwise, application can.
    char *traceBuffer;

    /// What is the allocated memory for buffer. Needed to check if appending string will be out of bounds.
    /// Application should set this, if the buffer is allocated by application, otherwise driver will set the value.
    size_t traceBufferSize;
} NeutronTraceConfig;

/* Invalid handle, returned by neutronModelPrepare() if an error occurred. */
#define NEUTRON_INVALID_HANDLE NULL

/// - Initialize the Neutron Driver library, setting initial values, do memory allocation
///   for internal data structures, do memory mapping.
NeutronError neutronInit();

/// - Deinitialize the Neutron Driver library, releasing any resources aquired by neutronInit
NeutronError neutronDeinit();

/// - Load the firmware into the Neutron subsystem.
/// - This function is only available for Neutron-S.
NeutronError neutronLoadFirmware(const void *firmware, size_t size);

/// - Prepare Neutron execution for a model with the given configuration.
/// - This function only prepares the execution by transferring the parameters to the firmware.
/// - This function allows caching a model and then running the same model but with different
///   input data (assuming the new input data replaces the old input data by reusing the same buffers).
NeutronError neutronModelPrepare(const NeutronModelConfig *mcfg, NeutronModelHandle *hdl);

/// - Unprepare Neutron execution handle.
/// - This function releases the internal context data structures and the reserved handle.
NeutronError neutronModelUnprepare(NeutronModelHandle hdl);

/// - Perform Neutron execution in blocking mode.
NeutronError neutronRunBlocking(NeutronModelHandle hdl, const NeutronDataConfig *dcfg);

/// - Perform Neutron execution in non-blocking mode.
/// - This functionality is only available for Neutron-S.
NeutronError neutronRunNonBlocking(NeutronModelHandle hdl, const NeutronDataConfig *dcfg);

/// Set tracing information.
void neutronSetTrace(NeutronModelHandle hdl, NeutronTraceConfig *tcfg);

/// - Wait (block) for Neutron completion.
/// - This functionality is only available for Neutron-S.
NeutronError neutronWait();

/// - Prepare a triggered execution.
/// - The Neutron execution is triggered whenever the "source" signal is generated in the system.
/// - The Neutron execution generates in return the "sink" signal when completed.
NeutronError neutronSetTriggers(NeutronSignal *source, NeutronSignal *sink);

/// - Abort any on-going Neutron execution (if any).
/// - This functionality is only available for Neutron-S.
NeutronError neutronAbort();

NeutronError neutronGetTrace(NeutronModelHandle hdl, char **buffer, size_t *size);

/// Other functions to control the state of driver/firmware.
#ifdef __cplusplus
}
#endif
#endif // NEUTRON_DRIVER_H
